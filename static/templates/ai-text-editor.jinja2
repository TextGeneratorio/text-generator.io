{% extends 'templates/base.jinja2' %}

{% block title %}AI Text Editor | Create Documents with AI-Powered Autocomplete{% endblock %}

{% block meta_description %}Create and edit documents with AI-powered autocomplete in a beautiful WYSIWYG editor. Write faster and smarter with AI assistance.{% endblock %}

{% block css %}
<link rel="stylesheet" href="{{ static_url }}/css/text-generator-docs.css">
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
<style>
  /* Full-width editor styles */
  .tgdocs-container {
    display: flex;
    flex-direction: column;
    width: 100%;
    max-width: 100%;
    margin: 0 auto;
    padding: 0;
  }
  
  .tgdocs-main {
    display: flex;
    width: 100%;
    height: calc(100vh - 130px);
  }
  
  .tgdocs-sidebar {
    width: 250px;
    background-color: #f9f9f9;
    border-right: 1px solid #e0e0e0;
    overflow-y: auto;
    transition: width 0.3s ease;
  }
  
  .tgdocs-sidebar.collapsed {
    width: 0;
    border: none;
  }
  
  .tgdocs-editor-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    background-color: white;
  }
  
  .tgdocs-toolbar {
    padding: 10px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #e0e0e0;
  }
  
  .tgdocs-doc-title {
    font-size: 20px;
    border: none;
    outline: none;
    background: transparent;
    width: 300px;
  }
  
  #editor {
    height: 100%;
    overflow-y: auto;
    width: 100%; /* Full width */
  }
  
  .ql-editor {
    font-size: 16px;
    width: 100%; /* Full width */
    min-height: calc(100vh - 200px);
    padding: 20px;
  }
  
  /* Improve suggestion styles */
  .suggestion-marker {
    display: none;
  }
  
  .inline-suggestion {
    display: inline !important;
    color: #999 !important;
    opacity: 0.6 !important;
    user-select: none !important;
    pointer-events: none !important;
    background-color: rgba(240, 240, 240, 0.3) !important;
    visibility: visible !important;
    position: relative !important;
    z-index: 5 !important;
  }
  
  /* Responsive styling */
  @media (max-width: 768px) {
    .tgdocs-sidebar {
      width: 200px;
    }
    
    .tgdocs-toolbar {
      flex-direction: column;
      align-items: flex-start;
    }
    
    .tgdocs-actions {
      margin-top: 10px;
    }
  }
</style>
{% endblock %}

{% block mainbody %}
<div class="tgdocs-container">
  <div class="tgdocs-main">
    <div class="tgdocs-sidebar">
      <div class="tgdocs-sidebar-header">
        <h3>My Documents</h3>
        <button id="new-doc-btn" class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab">
          <i class="material-icons">add</i>
        </button>
      </div>
      <div class="tgdocs-documents-list" id="documents-list">
        <!-- Documents will be listed here -->
      </div>
    </div>

    <div class="tgdocs-editor-container">
      <div class="tgdocs-toolbar">
        <input type="text" id="doc-title" class="tgdocs-doc-title" placeholder="Untitled Document">
        <div class="tgdocs-actions">
          <button id="toggle-sidebar-btn" class="mdl-button mdl-js-button mdl-button--icon">
            <i class="material-icons">menu</i>
          </button>
          <button id="generate-content-btn" class="mdl-button mdl-js-button mdl-button--raised mdl-button--colored">
            Generate (Alt+Enter)
          </button>
          <button id="save-doc-btn" class="mdl-button mdl-js-button mdl-button--raised mdl-button--colored">
            Save
          </button>
          <button id="export-doc-btn" class="mdl-button mdl-js-button mdl-button--raised">
            Export
          </button>
        </div>
      </div>
      
      <div id="editor">
        <!-- This is where the Quill editor will be initialized -->
      </div>
      
      <!-- Visible suggestion container for non-inline suggestions -->
      <div id="autocomplete-suggestion" class="tgdocs-autocomplete-suggestion" style="display: none;">
        <span class="suggestion-text"></span>
        <span class="suggestion-info">Press Tab to accept</span>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block js %}
<script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
<script>
  // Create the enhanced TextGeneratorDocs class in-page to avoid external dependencies
  const Delta = Quill.import('delta');
  
  /**
   * AI Text Editor with race condition fixes and enhanced UI
   */
  class AITextEditor {
    constructor(options) {
      this.options = options || {};
      
      // DOM elements
      this.editorContainer = this.getElement(options.editorContainer);
      this.documentsList = this.getElement(options.documentsList);
      this.newDocButton = this.getElement(options.newDocButton);
      this.saveDocButton = this.getElement(options.saveDocButton);
      this.exportDocButton = this.getElement(options.exportDocButton);
      this.docTitleInput = this.getElement(options.docTitleInput);
      this.generateContentButton = this.getElement(options.generateContentButton);
      this.toggleSidebarButton = this.getElement(options.toggleSidebarButton);
      this.suggestionElement = this.getElement(options.suggestionElement);
      
      // Generation settings
      this.generationSettings = options.generationSettings || {
        number_of_results: 1,
        max_length: 100,
        max_sentences: 1,
        min_probability: 0.8, // Using 0.8 as requested
        stop_sequences: [],
        top_p: 0.9,
        top_k: 40,
        temperature: 0.7,
        repetition_penalty: 1.17,
        seed: 0
      };
      
      // State management
      this.currentDocId = null;
      this.currentDocData = null;
      this.documents = [];
      this.debounceTimeout = null;
      this.autosaveTimeout = null;
      this.isGenerating = false;
      this.suggestionText = '';
      this.suggestionActive = false;
      this.pendingSuggestionRequests = {};
      this.completionRequestCounter = 0;
      this.completionPrefixes = {};
      this.textChangeCounter = 0;
      
      // Load the secret key for API access
      this.secret = this.getSecretKey();
      
      // Get or create anonymous user ID for localStorage
      this.anonymousUserId = localStorage.getItem('ai-texteditor-anonymous-user-id');
      if (!this.anonymousUserId) {
        this.anonymousUserId = 'anon_' + Date.now();
        localStorage.setItem('ai-texteditor-anonymous-user-id', this.anonymousUserId);
      }
      
      // Completion cache
      this.completionCache = this.loadCompletionCache();
      this.maxCacheSize = 1000;
      
      // Initialize the editor
      this.init();
    }
    
    // Helper function to safely get DOM elements
    getElement(element) {
      if (typeof element === 'string') {
        return document.getElementById(element);
      }
      return element || null;
    }
    
    // Load the completion cache from localStorage
    loadCompletionCache() {
      try {
        const cachedData = localStorage.getItem('ai-texteditor-completion-cache');
        return cachedData ? JSON.parse(cachedData) : {};
      } catch (e) {
        console.error('Error loading completion cache:', e);
        return {};
      }
    }
    
    // Save the completion cache to localStorage
    saveCompletionCache() {
      try {
        localStorage.setItem('ai-texteditor-completion-cache', JSON.stringify(this.completionCache));
      } catch (e) {
        console.error('Error saving completion cache:', e);
      }
    }
    
    // Add an item to the LRU cache
    addToCompletionCache(prefix, completion) {
      // Get the cache keys and create a new object for LRU behavior
      const cacheKeys = Object.keys(this.completionCache);
      const newCache = {};
      
      // Add the new item first (or move to front if it exists)
      newCache[prefix] = {
        completion,
        timestamp: Date.now()
      };
      
      // If we're at max capacity, remove oldest items
      if (cacheKeys.length >= this.maxCacheSize) {
        // Sort by timestamp (oldest first)
        const sortedEntries = Object.entries(this.completionCache)
          .sort((a, b) => a[1].timestamp - b[1].timestamp);
        
        // Remove oldest entries to make room
        const entriesToKeep = sortedEntries.slice(
          sortedEntries.length - this.maxCacheSize + 1
        );
        
        // Add remaining entries to the new cache
        for (const [key, value] of entriesToKeep) {
          if (key !== prefix) { // Skip the one we just added
            newCache[key] = value;
          }
        }
      } else {
        // If not at capacity, just add all other entries
        for (const key of cacheKeys) {
          if (key !== prefix) { // Skip the one we just added
            newCache[key] = this.completionCache[key];
          }
        }
      }
      
      // Update cache and save to localStorage
      this.completionCache = newCache;
      this.saveCompletionCache();
    }
    
    // Get an item from the cache
    getFromCompletionCache(prefix) {
      const cacheItem = this.completionCache[prefix];
      if (cacheItem) {
        // Update timestamp when accessed (LRU behavior)
        cacheItem.timestamp = Date.now();
        return cacheItem.completion;
      }
      return null;
    }
    
    async init() {
      // Initialize the editor if the container exists
      if (this.editorContainer) {
        this.initEditor();
      } else {
        console.error('Editor container not found');
        return;
      }
      
      // Initialize event listeners
      this.initEventListeners();
      
      // Check user authentication
      const isAuthenticated = await this.checkUserAuthentication();
      
      // Load documents if authenticated
      if ((isAuthenticated || this.userId) && this.documentsList) {
        this.loadDocuments();
      } else {
        // Show login prompt if not authenticated
        this.showLoginPrompt();
      }
    }
    
    initEditor() {
      try {
        // Create inline suggestion blot
        const Inline = Quill.import('blots/inline');
        class SuggestionBlot extends Inline {
          static create(value) {
            let node = super.create();
            node.setAttribute('data-suggestion', value);
            // Add important inline styles to ensure visibility
            node.style.cssText = `
              display: inline !important;
              color: #999 !important;
              opacity: 0.6 !important;
              user-select: none !important;
              pointer-events: none !important;
              background-color: rgba(240, 240, 240, 0.3) !important;
              visibility: visible !important;
              position: relative !important;
              z-index: 5 !important;
            `;
            return node;
          }
          
          static value(node) {
            return node.getAttribute('data-suggestion');
          }
        }
        
        SuggestionBlot.blotName = 'suggestion';
        SuggestionBlot.tagName = 'span';
        SuggestionBlot.className = 'inline-suggestion';
        
        Quill.register(SuggestionBlot);
        
        // Ensure suggestion styles are applied
        this.addSuggestionStyles();
        
        // Initialize the Quill editor
        this.editor = new Quill(this.editorContainer, {
          theme: 'snow',
          modules: {
            toolbar: [
              [{ 'header': [1, 2, 3, false] }],
              ['bold', 'italic', 'underline', 'strike'],
              ['blockquote', 'code-block'],
              [{ 'list': 'ordered'}, { 'list': 'bullet' }],
              ['link', 'image'],
              ['clean']
            ]
          },
          placeholder: 'Start writing or press Alt+Enter to generate content...'
        });
        
        // Apply highlighting to code blocks after content changes
        this.editor.on('text-change', this.handleEditorChange.bind(this));
        
        // Focus on editor
        this.editor.focus();
      } catch (e) {
        console.error('Error initializing editor:', e);
      }
    }
    
    addSuggestionStyles() {
      // Check if our suggestion style enforcement is already in the document
      if (!document.getElementById('suggestion-style-enforcer')) {
        const style = document.createElement('style');
        style.id = 'suggestion-style-enforcer';
        // More specific selector to increase specificity and override potential conflicts
        style.textContent = `
          span.inline-suggestion, 
          .ql-editor span.inline-suggestion {
            display: inline !important;
            color: #999 !important;
            opacity: 0.6 !important;
            user-select: none !important;
            pointer-events: none !important;
            background-color: rgba(240, 240, 240, 0.3) !important;
            visibility: visible !important;
            position: relative !important;
            z-index: 5 !important;
          }
          
          /* Ensure editor has full width */
          .ql-container,
          .ql-editor {
            width: 100% !important;
          }
        `;
        document.head.appendChild(style);
      }
    }
    
    initEventListeners() {
      // Document management buttons
      if (this.newDocButton) {
        this.newDocButton.addEventListener('click', this.createNewDocument.bind(this));
      }
      
      if (this.saveDocButton) {
        this.saveDocButton.addEventListener('click', this.saveCurrentDocument.bind(this));
      }
      
      if (this.exportDocButton) {
        this.exportDocButton.addEventListener('click', this.exportCurrentDocument.bind(this));
      }
      
      if (this.generateContentButton) {
        this.generateContentButton.addEventListener('click', this.showGenerateContentDialog.bind(this));
      }
      
      if (this.toggleSidebarButton) {
        this.toggleSidebarButton.addEventListener('click', this.toggleSidebar.bind(this));
      }
      
      // Title change event
      if (this.docTitleInput) {
        this.docTitleInput.addEventListener('input', this.handleTitleChange.bind(this));
      }
      
      // Keyboard event listeners for suggestion handling
      document.addEventListener('keydown', this.handleKeyDown.bind(this));
      
      if (this.editor) {
        // Track cursor movement to hide suggestions when cursor moves
        this.editor.on('selection-change', (range, oldRange, source) => {
          if (this.suggestionActive && range && oldRange && 
              Math.abs(range.index - oldRange.index) > 3) {
            this.hideSuggestion();
          }
        });
        
        // Add keydown handler directly to editor for better detection
        this.editor.root.addEventListener('keydown', (e) => {
          // Any keypress except Tab should hide suggestion
          if (e.key !== 'Tab' && e.key !== 'Escape' && 
              e.key !== 'Control' && e.key !== 'Alt' && 
              e.key !== 'Shift' && e.key !== 'Meta') {
            if (this.suggestionActive) {
              this.hideSuggestion();
            }
            this.textChangeCounter++;
          }
        }, true);
      }
    }
    
    toggleSidebar() {
      const sidebar = document.querySelector('.tgdocs-sidebar');
      if (sidebar) {
        sidebar.classList.toggle('collapsed');
      }
    }
    
    handleEditorChange(delta, oldDelta, source) {
      if (source !== 'user') return;
      
      // Increment the text change counter to invalidate in-flight requests
      this.textChangeCounter++;
      
      // Clear any active suggestion
      if (this.suggestionActive) {
        this.hideSuggestion();
      }
      
      // Clear any existing autocomplete debounce
      clearTimeout(this.debounceTimeout);
      
      // Debounce autocomplete (2 seconds)
      this.debounceTimeout = setTimeout(() => {
        this.generateAutocompleteSuggestion();
      }, 2000);
      
      // AUTOSAVE HANDLING
      // Clear any existing autosave debounce
      clearTimeout(this.autosaveTimeout);
      
      // Show saving indicator
      this.updateSaveStatus('Saving...');
      
      // Debounce autosave (1 minute)
      this.autosaveTimeout = setTimeout(() => {
        this.autosaveCurrentDocument();
      }, 60000);
    }
    
    updateSaveStatus(message) {
      try {
        // Create or update save status element
        if (!this.saveStatusElement) {
          this.saveStatusElement = document.createElement('div');
          this.saveStatusElement.className = 'tgdocs-save-status';
          this.saveStatusElement.style.position = 'fixed';
          this.saveStatusElement.style.bottom = '10px';
          this.saveStatusElement.style.right = '10px';
          this.saveStatusElement.style.padding = '5px 10px';
          this.saveStatusElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
          this.saveStatusElement.style.color = '#fff';
          this.saveStatusElement.style.borderRadius = '3px';
          this.saveStatusElement.style.zIndex = '1000';
          this.saveStatusElement.style.opacity = '0.8';
          this.saveStatusElement.style.transition = 'opacity 0.3s ease-in-out';
          document.body.appendChild(this.saveStatusElement);
        }
        
        this.saveStatusElement.textContent = message;
        this.saveStatusElement.style.opacity = '0.8';
        
        // Add 'saved' class if message indicates successful save
        if (message === 'Saved') {
          this.saveStatusElement.classList.add('saved');
          
          // Fade out the status after 2 seconds
          setTimeout(() => {
            if (this.saveStatusElement) {
              this.saveStatusElement.style.opacity = '0';
            }
          }, 2000);
        } else {
          this.saveStatusElement.classList.remove('saved');
        }
      } catch (e) {
        console.error('Error updating save status:', e);
      }
    }
    
    async checkUserAuthentication() {
      try {
        // Try to get current user from API
        try {
          const response = await fetch('/api/current-user');
          if (response.ok) {
            const userData = await response.json();
            if (userData && userData.userId) {
              this.userId = userData.userId;
              return true;
            }
          }
        } catch (error) {
          console.log("API error when checking authentication:", error);
        }
        
        // Check if we have a secret key
        if (this.secret) {
          // Use a temporary user ID based on the secret key
          this.userId = 'user_' + this.hashString(this.secret);
          return true;
        }
        
        // Fallback to anonymous user ID for localStorage
        this.userId = this.anonymousUserId;
        
        // Show login prompt if we don't have a real user or secret
        this.showLoginPrompt();
        return false;
      } catch (error) {
        console.error('Error checking authentication:', error);
        
        // Fallback to anonymous user ID
        this.userId = this.anonymousUserId;
        return false;
      }
    }
    
    // Simple string hashing function for creating user IDs from secrets
    hashString(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      return Math.abs(hash).toString(16);
    }
    
    // AUTOCOMPLETE SUGGESTIONS HANDLING WITH RACE CONDITION FIX
    async generateAutocompleteSuggestion() {
      try {
        // Check if editor exists and is focused
        if (!this.editor || !this.editor.hasFocus()) {
          return;
        }
        
        // Don't generate if already generating or if suggestion is active
        if (this.isGenerating || this.suggestionActive) {
          return;
        }
        
        const text = this.editor.getText();
        const selection = this.editor.getSelection();
        if (!selection) return;
        
        const cursorPosition = selection.index;
        const textBeforeCursor = text.substring(0, cursorPosition);
        
        // If text is too short for suggestion, skip
        if (textBeforeCursor.length < 5) return;
        
        // Create a unique request ID
        const requestId = ++this.completionRequestCounter;
        
        // Store the prefix and cursor position with this request ID
        this.completionPrefixes[requestId] = {
          prefix: textBeforeCursor,
          position: cursorPosition,
          timestamp: Date.now(),
          changeCounter: this.textChangeCounter
        };
        
        // Check cache first (fast path)
        const cachedSuggestion = this.getFromCompletionCache(textBeforeCursor);
        if (cachedSuggestion && !this.suggestionActive) {
          console.log("Using cached suggestion");
          this.showInlineSuggestion(cachedSuggestion, cursorPosition, requestId);
          return;
        }
        
        // Fetch from API with request tracking
        this.isGenerating = true;
        
        try {
          console.log(`Getting suggestion for request ${requestId}`);
          
          // Save snapshot of text change counter when request is made
          const changeCounterAtRequest = this.textChangeCounter;
          
          // Call API with proper settings
          const response = await fetch('https://api.text-generator.io/api/v1/generate', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'secret': this.secret
            },
            body: JSON.stringify({
              ...this.generationSettings,
              text: textBeforeCursor
            })
          });
          
          // Check if request is still valid (text hasn't changed since request was made)
          if (this.textChangeCounter !== changeCounterAtRequest) {
            console.log(`Request ${requestId} is no longer valid - text changed`);
            return;
          }
          
          if (!response.ok) {
            console.error(`API error: ${response.status}`);
            return;
          }
          
          const data = await response.json();
          
          // Check again if request is still valid
          if (this.textChangeCounter !== changeCounterAtRequest) {
            console.log(`Request ${requestId} is no longer valid after JSON parsing - text changed`);
            return;
          }
          
          // Process the response - extract generated text after the prefix
          if (data && Array.isArray(data) && data.length > 0) {
            const generatedText = data[0].generated_text;
            const suggestion = generatedText.substring(textBeforeCursor.length);
            
            if (suggestion && suggestion.trim() !== '') {
              // Cache the suggestion
              this.addToCompletionCache(textBeforeCursor, suggestion);
              
              // Show suggestion if still valid and no suggestion is active
              if (this.textChangeCounter === changeCounterAtRequest && !this.suggestionActive) {
                this.showInlineSuggestion(suggestion, cursorPosition, requestId);
              } else {
                console.log(`Not showing suggestion - context changed or already showing one`);
              }
            }
          }
        } catch (error) {
          console.error('Error generating text:', error);
        } finally {
          this.isGenerating = false;
          delete this.completionPrefixes[requestId];
        }
      } catch (e) {
        console.error('Error in generateAutocompleteSuggestion:', e);
        this.isGenerating = false;
      }
    }
    
    showInlineSuggestion(suggestion, position, requestId) {
      if (!suggestion || suggestion.trim() === '' || this.suggestionActive) return;
      
      // First remove any existing suggestions
      this.removeInlineSuggestion();
      
      // Store suggestion
      this.suggestionText = suggestion;
      this.suggestionActive = true;
      
      try {
        // Two approaches for displaying the suggestion:
        // 1. DOM-based approach - more reliable for this UI
        if (this.suggestionElement) {
          // Get current editor position
          const bounds = this.editor.getBounds(position);
          
          // Set the text content
          const textEl = this.suggestionElement.querySelector('.suggestion-text');
          if (textEl) {
            textEl.textContent = suggestion;
          }
          
          // Position the element
          if (bounds) {
            this.suggestionElement.style.top = `${bounds.top}px`;
            this.suggestionElement.style.left = `${bounds.left}px`;
            this.suggestionElement.style.display = 'block';
            
            // Store position for validation when accepting
            this.suggestionElement.dataset.position = position.toString();
            this.suggestionElement.dataset.requestId = requestId?.toString() || '';
          }
        }
        
        // 2. Insert suggestion into editor with special formatting
        const currentLength = this.editor.getLength();
        
        // Save current selection
        const savedSelection = this.editor.getSelection();
        
        // Insert the suggestion with the suggestion format
        this.editor.insertText(position, suggestion, { 'suggestion': true });
        
        // Restore cursor position
        this.editor.setSelection(savedSelection);
        
        // Force a repaint to ensure suggestion visibility 
        setTimeout(() => {
          // Ensure suggestion spans have correct styling
          const suggestions = document.querySelectorAll('.inline-suggestion');
          suggestions.forEach(el => {
            el.style.cssText = `
              display: inline !important;
              color: #999 !important;
              opacity: 0.6 !important;
              user-select: none !important;
              pointer-events: none !important;
              background-color: rgba(240, 240, 240, 0.3) !important;
              visibility: visible !important;
              position: relative !important;
              z-index: 5 !important;
            `;
          });
        }, 10);
      } catch (e) {
        console.error('Error showing suggestion:', e);
        this.suggestionActive = false;
      }
    }
    
    removeInlineSuggestion() {
      if (!this.suggestionActive) return;
      
      try {
        // Hide the suggestion UI element
        if (this.suggestionElement) {
          this.suggestionElement.style.display = 'none';
          this.suggestionElement.removeAttribute('data-position');
          this.suggestionElement.removeAttribute('data-request-id');
        }
        
        // Remove any inline suggestion elements
        const suggestionElements = document.querySelectorAll('.inline-suggestion');
        suggestionElements.forEach(el => {
          el.parentNode?.removeChild(el);
        });
        
        // Reset suggestion state
        this.suggestionActive = false;
        this.suggestionText = '';
      } catch (e) {
        console.error('Error removing suggestion:', e);
      }
    }
    
    hideSuggestion() {
      this.removeInlineSuggestion();
    }
    
    acceptSuggestion() {
      if (!this.suggestionActive || !this.editor) return;
      
      try {
        // Get current selection
        const selection = this.editor.getSelection();
        if (!selection) return;
        
        const cursorPosition = selection.index;
        
        // Get the stored position of the suggestion
        const suggestionPosition = parseInt(this.suggestionElement.dataset.position || '0');
        
        // Check if cursor is close to where suggestion was shown (within 5 chars)
        if (Math.abs(cursorPosition - suggestionPosition) > 5) {
          console.log('Cursor moved too far from suggestion position, not accepting');
          this.hideSuggestion();
          return;
        }
        
        // Get the suggestion text
        const suggestionTextEl = this.suggestionElement.querySelector('.suggestion-text');
        const suggestionText = suggestionTextEl ? suggestionTextEl.textContent : '';
        
        if (!suggestionText) {
          this.hideSuggestion();
          return;
        }
        
        // Remove any inline suggestion spans first
        this.hideSuggestion();
        
        // Insert the suggestion text at cursor position
        this.editor.insertText(cursorPosition, suggestionText);
        
        // Set cursor position after the inserted text
        this.editor.setSelection(cursorPosition + suggestionText.length, 0);
        
        // Force editor to focus after insertion
        this.editor.focus();
      } catch (error) {
        console.error('Error accepting suggestion:', error);
        this.hideSuggestion();
      }
    }
    
    handleKeyDown(event) {
      // If editor is not initialized, don't handle keyboard events
      if (!this.editor) {
        return;
      }
      
      // Tab key to accept suggestion
      if (event.key === 'Tab' && this.suggestionActive) {
        event.preventDefault();
        event.stopPropagation();  // Prevent default tab behavior
        this.acceptSuggestion();
        return false;  // Make sure tab doesn't propagate
      }
      
      // Escape to dismiss suggestion
      if (event.key === 'Escape' && this.suggestionActive) {
        event.preventDefault();
        this.hideSuggestion();
        return;
      }
      
      // Alt+Enter to generate content (cross-browser support)
      if ((event.key === 'Enter' && event.altKey) || (event.keyCode === 13 && event.altKey)) {
        event.preventDefault();
        event.stopPropagation(); // Prevent the event from bubbling up
        
        // Cancel any active suggestion first
        if (this.suggestionActive) {
          this.hideSuggestion();
        }
        
        // Get text before cursor to use as prompt
        const selection = this.editor.getSelection();
        if (selection) {
          const text = this.editor.getText();
          const textBeforeCursor = text.substring(0, selection.index);
          
          // Get the last several words to use as context
          const lastFewWords = textBeforeCursor.split(/\s+/).slice(-15).join(' ').trim();
          
          if (lastFewWords.length > 0) {
            // Show a brief visual feedback that generation is happening
            this.updateSaveStatus('Generating...');
            
            // Generate content using text before cursor as prompt
            setTimeout(() => {
              this.insertLLMResponse(lastFewWords, true);
            }, 10);
          } else {
            // If there's no text before cursor, show the generate dialog instead
            this.showGenerateContentDialog();
          }
        }
        
        return false; // Ensure the event is fully handled
      }
    }
    
    async loadDocuments() {
      if (!this.userId) return;
      
      try {
        // Try to get documents from database via API
        try {
          const response = await fetch(`/api/docs/list?userId=${this.userId}`, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          if (response.ok) {
            const data = await response.json();
            this.documents = data.documents || [];
          } else {
            // API endpoint not available, use localStorage as fallback
            console.log("API endpoint not available, using localStorage fallback");
            this.loadDocumentsFromLocalStorage();
          }
        } catch (error) {
          // Network error or API not available, use localStorage as fallback
          console.log("API error, using localStorage fallback:", error);
          this.loadDocumentsFromLocalStorage();
        }
        
        this.renderDocumentsList();
        
        // If there are documents, load the first one
        if (this.documents.length > 0) {
          this.loadDocument(this.documents[0].id);
        } else {
          this.createNewDocument();
        }
      } catch (error) {
        console.error('Error loading documents:', error);
        // Fallback to empty state
        this.documents = [];
        this.renderDocumentsList();
        this.createNewDocument();
      }
    }
    
    loadDocumentsFromLocalStorage() {
      // Get documents from localStorage
      try {
        const storedDocs = localStorage.getItem(`ai-texteditor-documents-${this.userId}`);
        if (storedDocs) {
          this.documents = JSON.parse(storedDocs);
        } else {
          this.documents = [];
        }
      } catch (e) {
        console.error('Error loading from localStorage:', e);
        this.documents = [];
      }
    }
    
    renderDocumentsList() {
      if (!this.documentsList) return;
      
      // Clear list
      this.documentsList.innerHTML = '';
      
      // Add each document to the list
      this.documents.forEach(doc => {
        const docItem = document.createElement('div');
        docItem.className = 'tgdocs-document-item';
        if (this.currentDocId === doc.id) {
          docItem.classList.add('active');
        }
        
        const title = document.createElement('h4');
        title.className = 'tgdocs-document-title';
        title.textContent = doc.title || 'Untitled Document';
        
        const date = document.createElement('div');
        date.className = 'tgdocs-document-date';
        date.textContent = this.formatDate(doc.updatedAt);
        
        docItem.appendChild(title);
        docItem.appendChild(date);
        
        // Add click event to load document
        docItem.addEventListener('click', () => {
          this.loadDocument(doc.id);
        });
        
        this.documentsList.appendChild(docItem);
      });
    }
    
    formatDate(timestamp) {
      if (!timestamp) return '';
      const date = new Date(timestamp);
      return date.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric', 
        year: 'numeric' 
      });
    }
    
    async loadDocument(docId) {
      try {
        // Try to load from API first
        try {
          const response = await fetch(`/api/docs/get?id=${docId}`, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          if (response.ok) {
            const docData = await response.json();
            this.currentDocId = docId;
            this.currentDocData = docData;
            
            // Update title
            this.docTitleInput.value = docData.title || '';
            
            // Update editor content
            this.editor.setContents(JSON.parse(docData.content));
            
            // Update active document in list
            this.renderDocumentsList();
            return;
          }
        } catch (error) {
          console.log("API error when loading document, using localStorage:", error);
        }
        
        // Fallback to localStorage if API fails
        const doc = this.documents.find(d => d.id === docId);
        if (doc) {
          this.currentDocId = docId;
          this.currentDocData = doc;
          
          // Update title
          this.docTitleInput.value = doc.title || '';
          
          // Update editor content
          this.editor.setContents(JSON.parse(doc.content));
          
          // Update active document in list
          this.renderDocumentsList();
        } else {
          throw new Error('Document not found in localStorage');
        }
      } catch (error) {
        console.error('Error loading document:', error);
        this.showMessage('Error loading document', 'error');
      }
    }
    
    async saveCurrentDocument() {
      if (!this.userId) {
        this.showLoginPrompt();
        return;
      }
      
      const content = JSON.stringify(this.editor.getContents());
      const title = this.docTitleInput.value || 'Untitled Document';
      
      const documentData = {
        userId: this.userId,
        title,
        content
      };
      
      if (this.currentDocId) {
        documentData.id = this.currentDocId;
      } else {
        // Generate a new ID if this is a new document
        documentData.id = 'doc_' + Date.now();
      }
      
      try {
        // Try to save to API first
        let apiSaveSuccessful = false;
        
        try {
          const response = await fetch('/api/docs/save', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(documentData)
          });
          
          if (response.ok) {
            const result = await response.json();
            apiSaveSuccessful = true;
            
            // Update current document ID if it was a new document
            if (!this.currentDocId) {
              this.currentDocId = result.id || documentData.id;
              documentData.id = this.currentDocId;
            }
          }
        } catch (error) {
          console.log("API error when saving, using localStorage:", error);
        }
        
        // If API save failed, save to localStorage
        if (!apiSaveSuccessful) {
          this.saveDocumentToLocalStorage(documentData);
        }
        
        // Show success message
        this.updateSaveStatus('Saved');
        
        // Update current document ID
        this.currentDocId = documentData.id;
        
        // Refresh documents list
        this.loadDocumentsFromLocalStorage();
        this.renderDocumentsList();
      } catch (error) {
        console.error('Error saving document:', error);
        this.updateSaveStatus('Save failed');
      }
    }
    
    saveDocumentToLocalStorage(documentData) {
      // Save the document to localStorage
      try {
        // Add timestamp
        documentData.updatedAt = new Date().toISOString();
        if (!documentData.createdAt) {
          documentData.createdAt = documentData.updatedAt;
        }
        
        // Update or add the document in the documents array
        const existingIndex = this.documents.findIndex(d => d.id === documentData.id);
        if (existingIndex >= 0) {
          this.documents[existingIndex] = documentData;
        } else {
          this.documents.push(documentData);
        }
        
        // Save to localStorage
        localStorage.setItem(`ai-texteditor-documents-${this.userId}`, JSON.stringify(this.documents));
        
        console.log("Document saved to localStorage:", documentData.id);
      } catch (e) {
        console.error('Error saving to localStorage:', e);
        throw e;
      }
    }
    
    async autosaveCurrentDocument() {
      try {
        // Check if editor and required elements exist
        if (!this.editor || !this.docTitleInput) {
          console.warn('Editor or document title input not initialized for autosave');
          return;
        }
        
        if (!this.userId) {
          return;
        }
        
        const content = JSON.stringify(this.editor.getContents());
        const title = this.docTitleInput.value || 'Untitled Document';
        
        const documentData = {
          userId: this.userId,
          title,
          content
        };
        
        if (this.currentDocId) {
          documentData.id = this.currentDocId;
        } else {
          // Generate a new ID if this is a new document
          documentData.id = 'doc_' + Date.now();
        }
        
        // Try to autosave to API first
        let apiSaveSuccessful = false;
        
        try {
          // First try the autosave endpoint
          let response = await fetch('/api/docs/autosave', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(documentData)
          });
          
          // If autosave endpoint fails, try the regular save endpoint
          if (!response.ok) {
            response = await fetch('/api/docs/save', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(documentData)
            });
          }
          
          if (response.ok) {
            const result = await response.json();
            apiSaveSuccessful = true;
            
            // Update current document ID if it was a new document
            if (!this.currentDocId) {
              this.currentDocId = result.id || documentData.id;
              documentData.id = this.currentDocId;
            }
          }
        } catch (error) {
          console.log("API error when autosaving, using localStorage:", error);
        }
        
        // If API save failed, save to localStorage
        if (!apiSaveSuccessful) {
          this.saveDocumentToLocalStorage(documentData);
        }
        
        // Update current document ID
        this.currentDocId = documentData.id;
        
        // Show success message
        this.updateSaveStatus('Saved');
      } catch (e) {
        console.error('Error in autosaveCurrentDocument:', e);
        this.updateSaveStatus('Autosave failed');
      }
    }
    
    createNewDocument() {
      // Clear current document ID and data
      this.currentDocId = null;
      this.currentDocData = null;
      
      // Clear title
      this.docTitleInput.value = 'Untitled Document';
      
      // Clear editor content
      this.editor.setContents([{ insert: '\n' }]);
      
      // Update active document in list
      this.renderDocumentsList();
      
      // Save the new document immediately to get an ID
      this.saveCurrentDocument();
      
      // Focus on editor
      this.editor.focus();
    }
    
    // LLM Generation handling
    async insertLLMResponse(prompt, isBulkGeneration = false) {
      if (!prompt || prompt.trim() === '') return;
      
      // Show loading indicator
      this.updateSaveStatus('Generating content...');
      
      // Save current cursor position
      const savedSelection = this.editor.getSelection();
      
      try {
        // Generate content using the API with adjusted settings for bulk generation
        const generationSettings = {...this.generationSettings};
        
        if (isBulkGeneration) {
          // For bulk generation, always set min_probability to 0
          generationSettings.min_probability = 0;
          generationSettings.max_length = 1000;
          generationSettings.max_sentences = 20;
          generationSettings.temperature = 0.8;
        }
        
        // Call the API to generate content
        const response = await fetch('https://api.text-generator.io/api/v1/generate', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'secret': this.secret
          },
          body: JSON.stringify({
            ...generationSettings,
            text: prompt
          })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error(`API Error (${response.status}): ${errorText}`);
          this.updateSaveStatus(`Generation failed: ${response.status} error`);
          return;
        }
        
        const data = await response.json();
        
        // If no data or empty array, return null
        if (!data || !Array.isArray(data) || data.length === 0) {
          console.warn('Empty or invalid response from API');
          this.updateSaveStatus('Generation received empty response');
          return;
        }
        
        // Process the response correctly - extract the generated text that comes after the prompt
        const generatedText = data[0].generated_text.substring(prompt.length);
        
        if (generatedText && generatedText.trim() !== '') {
          // Make sure cursor position is still valid
          if (savedSelection && this.editor) {
            // Restore cursor position
            this.editor.setSelection(savedSelection);
          }
          
          // Insert the text at cursor position
          const currentSelection = this.editor.getSelection() || savedSelection;
          if (currentSelection) {
            this.editor.insertText(currentSelection.index, generatedText);
            // Set the cursor to the end of the inserted text
            this.editor.setSelection(currentSelection.index + generatedText.length, 0);
          }
          
          // Update save status
          this.updateSaveStatus('Content inserted');
          
          // Autosave after inserting content
          this.autosaveCurrentDocument();
        } else {
          this.updateSaveStatus('Generated empty content');
        }
      } catch (error) {
        console.error('Error generating content:', error);
        this.updateSaveStatus('Generation failed');
      }
    }
    
    showGenerateContentDialog() {
      // Create dialog for generation options
      const dialog = document.createElement('div');
      dialog.className = 'tgdocs-generate-dialog';
      
      // Create dialog content
      const dialogContent = document.createElement('div');
      dialogContent.className = 'tgdocs-generate-dialog-content';
      dialogContent.innerHTML = `
        <h3>Generate Content</h3>
        <p>Enter a prompt to generate content using AI. The content will be inserted at your cursor position:</p>
        <textarea id="generate-prompt" class="tgdocs-generate-prompt" placeholder="Describe what you want to generate..."></textarea>
        <div class="tgdocs-generate-actions">
          <button id="generate-cancel" class="mdl-button mdl-js-button">Cancel</button>
          <button id="generate-submit" class="mdl-button mdl-js-button mdl-button--raised mdl-button--colored">Generate</button>
        </div>
      `;
      
      // Append dialog to body
      document.body.appendChild(dialog);
      dialog.appendChild(dialogContent);
      
      // Add event listeners
      document.getElementById('generate-cancel').addEventListener('click', () => {
        dialog.remove();
      });
      
      document.getElementById('generate-submit').addEventListener('click', () => {
        const prompt = document.getElementById('generate-prompt').value.trim();
        if (prompt) {
          this.insertLLMResponse(prompt, true);
          dialog.remove();
        }
      });
      
      // Focus on prompt input
      setTimeout(() => {
        document.getElementById('generate-prompt').focus();
      }, 100);
    }
    
    showLoginPrompt() {
      // Check if login prompt already exists
      if (document.querySelector('.tgdocs-login-prompt')) {
        return;
      }
      
      // Create login prompt
      const loginPrompt = document.createElement('div');
      loginPrompt.className = 'tgdocs-login-prompt';
      
      // Create login message
      const loginMessage = document.createElement('div');
      loginMessage.className = 'tgdocs-login-message';
      loginMessage.innerHTML = `
        <h2>Welcome to AI Text Editor</h2>
        <p>Please sign in to continue:</p>
        <div class="tgdocs-login-options">
          <button id="login-with-google" class="tgdocs-login-button">Sign in with Google</button>
          <div class="tgdocs-login-divider">or</div>
          <div class="tgdocs-secret-input-container">
            <input type="text" id="secret-key-input" class="tgdocs-secret-input" placeholder="Enter your secret key">
            <button id="continue-with-secret" class="tgdocs-login-button">Continue</button>
          </div>
          <div class="tgdocs-login-divider">or</div>
          <button id="continue-offline" class="tgdocs-login-button">Continue Offline</button>
        </div>
      `;
      
      // Append login prompt to body
      document.body.appendChild(loginPrompt);
      loginPrompt.appendChild(loginMessage);
      
      // Add event listeners for login options
      document.getElementById('login-with-google').addEventListener('click', () => {
        // Redirect to Google login
        window.location.href = '/login';
      });
      
      document.getElementById('continue-with-secret').addEventListener('click', () => {
        const secretInput = document.getElementById('secret-key-input');
        const secret = secretInput.value.trim();
        
        if (secret) {
          // Store secret key
          this.secret = secret;
          this.setSecretKey(secret);
          
          // Set user ID based on secret
          this.userId = 'user_' + this.hashString(secret);
          
          // Remove login prompt
          loginPrompt.remove();
          
          // Load documents
          this.loadDocuments();
        } else {
          alert('Please enter a valid secret key');
        }
      });
      
      document.getElementById('continue-offline').addEventListener('click', () => {
        // Use anonymous user ID
        this.userId = this.anonymousUserId;
        
        // Remove login prompt
        loginPrompt.remove();
        
        // Load documents from localStorage
        this.loadDocumentsFromLocalStorage();
        this.renderDocumentsList();
        
        // Create new document if none exist
        if (this.documents.length === 0) {
          this.createNewDocument();
        } else {
          this.loadDocument(this.documents[0].id);
        }
      });
      
      // Focus on secret key input
      setTimeout(() => {
        document.getElementById('secret-key-input').focus();
      }, 100);
    }
    
    showMessage(message, type = 'success') {
      const snackbar = document.createElement('div');
      snackbar.className = `mdl-snackbar mdl-snackbar--${type}`;
      snackbar.textContent = message;
      document.body.appendChild(snackbar);
      
      // Auto remove after 3 seconds
      setTimeout(() => {
        document.body.removeChild(snackbar);
      }, 3000);
    }
    
    handleTitleChange() {
      // Clear any existing debounce for title changes
      clearTimeout(this.titleChangeDebounceTimer);
      
      // Show saving indicator
      this.updateSaveStatus('Saving...');
      
      // Debounce title changes (1 second)
      this.titleChangeDebounceTimer = setTimeout(() => {
        this.autosaveCurrentDocument();
      }, 1000);
    }
    
    getSecretKey() {
      // First check if there's a secret in the cookie
      const match = document.cookie.match(new RegExp('(^| )secret=([^;]+)'));
      if (match) return match[2];
      
      // Then check local storage
      const storedSecret = localStorage.getItem('textGeneratorSecret');
      if (storedSecret) return storedSecret;
      
      return '';
    }
    
    setSecretKey(secret) {
      // Store the secret key in both cookie and local storage
      document.cookie = `secret=${secret}; path=/; max-age=2592000`; // 30 days
      localStorage.setItem('textGeneratorSecret', secret);
      this.secret = secret;
    }
    
    exportCurrentDocument() {
      const content = this.editor.getText();
      const title = this.docTitleInput.value || 'untitled-document';
      
      // Create download link
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${title.replace(/\s+/g, '-').toLowerCase()}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
  }
  
  // Initialize the AI Text Editor on page load
  document.addEventListener('DOMContentLoaded', function() {
    // Initialize the text editor
    const textEditor = new AITextEditor({
      editorContainer: 'editor',
      documentsList: 'documents-list',
      newDocButton: 'new-doc-btn',
      saveDocButton: 'save-doc-btn',
      exportDocButton: 'export-doc-btn',
      docTitleInput: 'doc-title',
      generateContentButton: 'generate-content-btn',
      toggleSidebarButton: 'toggle-sidebar-btn',
      suggestionElement: 'autocomplete-suggestion',
      // Text generation settings with 0.8 min_probability
      generationSettings: {
        number_of_results: 1,
        max_length: 100,
        max_sentences: 1,
        min_probability: 0.8,
        stop_sequences: [],
        top_p: 0.9,
        top_k: 40,
        temperature: 0.7,
        repetition_penalty: 1.17,
        seed: 0
      }
    });
  });
</script>
{% endblock %}